# アーキテクチャ設計

## 概要

このチャットアプリケーションは、イベントソーシング（Event Sourcing）とコマンドクエリ責務分離（CQRS）のアーキテクチャパターンを使用して実装されています。これにより、データの整合性を保ちながら、読み取りと書き込みの操作を分離し、スケーラビリティと保守性を向上させています。

## アーキテクチャの主要コンポーネント

### ドメイン層

ドメイン層はビジネスロジックの中核を担当し、以下のコンポーネントで構成されています：

- **集約（Aggregate）**: `ChatRoom` エンティティとその振る舞いを定義します
- **コマンド（Commands）**: チャットルームに対して実行できる操作を定義します
  - `CreateRoom`: 新しいチャットルームを作成
  - `JoinRoom`: ユーザーがルームに参加
  - `LeaveRoom`: ユーザーがルームを退出
  - `SendMessage`: メッセージを送信
- **イベント（Events）**: 状態変更イベントとエラータイプを定義します
  - `RoomCreated`: ルーム作成イベント
  - `UserJoined`: ユーザー参加イベント
  - `UserLeft`: ユーザー退出イベント
  - `MessageSent`: メッセージ送信イベント

### サービス層

サービス層は外部統合とビューモデルを処理します：

- **ChatServices**: 通知操作を提供します
- **ChatRoomViewRepository**: CQRSのクエリ側を実装します
- **PostgresEventStore**: イベントの永続化を担当します

### UI層

UI層はユーザーインターフェースを提供します：

- **TUI**: 対話型チャット用のターミナルユーザーインターフェース
- **Web API**: プログラムによるアクセス用のRESTful API

## イベントソーシングの実装

イベントソーシングパターンでは、アプリケーションの状態変更はすべてイベントとして保存されます。これにより：

1. 完全な監査証跡が維持されます
2. 任意の時点の状態を再構築できます
3. イベントの再生によるシステム回復が可能になります

実装では、`PostgresEventStore`がイベントの保存と取得を担当し、`ChatRoom`集約がイベントを適用して状態を更新します。

## CQRSの実装

CQRSパターンでは、読み取り（クエリ）操作と書き込み（コマンド）操作が分離されています：

1. **コマンド側**: `ChatCommand`を通じてシステムの状態を変更します
2. **クエリ側**: `ChatRoomViewRepository`を通じて最適化されたビューモデルからデータを読み取ります

この分離により、各側面を独立して最適化でき、システムのスケーラビリティが向上します。

## データフロー

1. ユーザーがコマンド（例：メッセージ送信）を実行
2. コマンドハンドラーがコマンドを処理し、イベントを生成
3. イベントがイベントストアに保存される
4. イベントがビューモデルに適用され、読み取り最適化されたビューを更新
5. ユーザーはビューモデルからデータを読み取る

## 技術スタック

- **Rust**: 高性能で安全なシステムプログラミング言語
- **cqrs-es**: イベントソーシングとCQRSのためのRustライブラリ
- **PostgreSQL**: イベントストアとして使用されるデータベース
- **Cursive**: TUIフレームワーク
- **Actix Web**: Web APIフレームワーク
- **Tokio**: 非同期ランタイム
